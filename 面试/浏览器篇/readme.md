
# 为什么打开一个页面需要开启四个进程

1. 在以前单进程时期，一个线程挂了会导致整个浏览器挂掉，极其不稳定。

2. 当一个页面被阻塞了会导致其他页面没有机会执行，导致整个浏览器不流畅

3. 没有安全沙箱，恶意插件可以获取系统的一些信息，多进程把插件放在一个单独扽插件进程中。



# TCP 如何将数据包发送给运用程序

首先通过ip地址把数据发送给主机，ip地址可以想成是一个家庭地址 （网络层）

但是数据包发送给主机后，主机不知道是那个程序需要使用，这个时候就要使用UDP了，在UDP头部有一个端口号,通过端口号确认是那个程序使用 （传输层），但是UDP只保证速度，不保证可靠，所以其实我们大多数是使用TCP, TCP 有超时重传机制，三次握手，四次挥手等





















# DOM 树 和 渲染树 的区别：

DOM 树与 HTML 标签一一对应，包括 head 和隐藏元素
渲染树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的 css 属性
CSS

# CSS会阻塞DOM解析吗？

不会，但是会阻塞渲染树，dom解析和css解析是分开的

其实间接影响，原因看网络篇url


# 白屏原因

css 放在底部，js放在顶部，使用@import 加载css


# 浏览器与Node的事件循环(Event Loop)有何区别?


首先先执行macro任务，macro 队列里有且只有一个 script 脚本

然后执行macro任务中的同步代码，执行完同步代码后会询问是否有微任务执行，如果有则执行微任务，微任务可能会产生新的微任务，按栈的方式执行，执行完所有微任务后，执行一次ui回调，然后执行新的macro任务

总结 执行一个macro任务后，会执行完macro任务中的所有微任务，再执行新的macro任务。


node事件循环

timer 阶段 执行 timer函数

io阶段 执行非close的io事件

第三阶段是内部阶段

poll阶段 如果有timer函数，直接进入timer阶段，没有则询问是否有 setImmediate 回调需要执行，如果有poll 阶段会停止并且进入到 check 阶段执行回调
没有则询问执行队列是否为空，如果不为空会遍历执行直到执行完或者达到上限。

check阶段 执行setImmediate函数

close 执行io close事件

# 前端如何优化首屏加载速度？

和性能优化差不多

# 白屏时间 

从输入url到开始渲染的时间

# 首屏加载时间

从输入url到首屏渲染完成的时间


白屏时间可以通过谷歌面板 performance.timing.responseStart - performance.timing.navigationStart

首屏时间没有明确的定义



# 循环引用会造成什么危害

不恰当的循环引用不能被垃圾回收机制回收

# 为什么要有垃圾回收机制

浏览器 会根据我们生成的对象自动分配内存大小，自动分配了当然就要自动回收，要不然


# 标记清除

首先给所有在内存中的变量加上标记

清除运行环境中的变量和运行环境引用变量的标记

然后准备清除还有标记的变量

最后清除这些变量并释放内存

# 引用计数

声明变量 和引用变量计数+1 如果变量  改变了引用对象则计数-1

当计数为0的清除

现在基本已经不用了，因为循环引用的问题会导致变量永远不会被清除


# 垃圾回收算法

# 新生代 存放生命周期较短的变量

1 分为 form 和to两个空间

首先往form 加内存 ，标记不用的内存后，把剩余变量加入to空间，清除掉form空间的变量，然后交换from和to空间

# 旧生代 存放生命周期较长的变量

当新生代上面的步骤较多后，则认为是存活生命周期较长的变量


老生代 标记清除

只标记存活的对象，对没有标记的变量清除 ，造成的危害就是造成清除后内存不连续 

老生代 标记整理，

标记存活的对象同时将其移到内存的一侧，清除掉另一侧的对象即可



# JS 引擎工作原理

## 全局内存(堆)

从上往下读代码，将所有变量和函数放在全局变量中


## 调用栈

当执行一个函数的时候，会将函数推进调用栈中


## 全局执行上下文
执行全局函数

## 本地执行上下文


  