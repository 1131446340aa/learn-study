# vue2和vue3有什么区别

## 设计上

一：vue3使用components Api 取代 class 类的形式，这主要有2个好处

1:ts对this支持不是特别友好，vue使用class 形式，对一些插件例如vuex，vuerouter 这种都没有类型。

2:通过import引入对比vue2对象形式，import可以很好的做到treeShank ，而对象不可能做到。

二：使用provide /inject 注册插件取代以前使用mixins混入beforeCreate生命周期形式。

使用混入有三个缺点：
1:缺少this上的类型
2：某些组建根本没有使用vuex vue-router 也会进行混入
3:在vue2中，mixins有一些缺陷。稍后再说。

三：相比与以前vue2就是一个整体，而vue3更像是一个积木，对某些你不要的功能可以不拼接，单独的积木也可以单独使用。也可以重新设计自己的积木进行使用，例如重新设计自己的createApp，定义dom渲染的形式。

还可以将reactive单独在ts文件中使用,使用reactive对数据源进行包装，然后利用es6 import 对值引用的特性，做数据共享取代vuex，就是两个文件同时引用一个数据源

同时可以将一些代码封装到函数中，要使用的时候，页面直接引用就行，通过这种方式做到js共享，取代以前的mixins。mixins有一些缺陷，就是不容易追踪数据，逻辑混乱等，例如将，data，method 进行参数合并，生命周期加入队列然后遍历执行，你完全不知道数据来源和生命周期来自那个mixins

四：在vue3中可以更好的使用jsx/tsx，tsx相比与vue模板有什么好处

1：首先在vue的tsx中也可以使用一些指令，例如v-model.这是react都不具备的
2:tsx相当与在写ts，好处就是在dom中也可以使用ts类型检查，而template模板都是字符串，然后通过正则翻译。在template中不能使用ts。
3:tsx缺点：tsx写样式相对与vue有很大的差距，除此之外，性能也有一些差距
template模板在编译阶段先转化成ast树，然后对ast树遍历找出静态节点并将取提升到render函数之外（vue2进行标记）这样以后在数据改变是，和静态节点就没有半毛钱关系。
而tsx 完全就是利用babel ast词法分析对代码进行转译，而ts有很强的执行上下文，很难对静态节点进行优化，因为可能改变上下文环境。

五：可以使用vite打包工具

vite 本质上就是一个koa服务器。

vite相比与webpack

先说缺点，生态不足，碰到问题很难解决，另外教程不足。

优点:利用es6 import 天生做到按需加载，打包速度是webpack的几倍-几十倍

原理：简单说一下.主要自己也理解不深

主要利用es6 import 而，import只对 / ， ./ ,../ 前缀的生效，

所以我们要先分析那些模块没有这些前缀，就是一些第三方包，然后给这些模块加一个前缀，例如/@node—modules.

然后加了前缀就要找到真正的包，所以要进行map进行一下映射，请求真正的包。

很久没看，忘记了。。。。。


vite 热更新简介， 利用node 监听文件变化模块，同时建立websocket链接，文件一变化，就给客服端发送一个请求，客服端调用reload进行更新



## 功能上

基本兼容vue2 ， 对某些api进行破坏了，例如$on,beforeCreate 

新加css 属性响应式，dom传送门，watch改为监听数组，就是可以同时监听多个值，
watchEffect 等等 ，这些都没有什么说的，基本功能。

使用reactive 代替以前的data，主要就是可以直接对数组进行响应式，同时可以定义多个数据源。

直接声明一个变量然后return 就可以在模板中使用，以前vue2定义不响应的数据只能使用Object.freeze()对对象进行冻结。


others。。。。乱七八糟一堆没必要说




## 原理上
其实前面已经或多或少说了一些原理，这里简单说一下几个核心api原理

响应式原理对比：

相比与以前使用Object.defineProperty 拦截数组原型链，重写数组方法那些破烂，
vue3使用proxy可以直接使数组相应，只要注意修改数组长度会触发两次，因为length属性也改变了。

然后就是proxy代理的是对象，Object.defineProperty代理的是属性，这直接少了一次for循环，而且加上各种递归，少了很多时间复杂度
另外就是vue2在一开始就对数据进行深度递归，而vue3是在get中进行懒递归，但只有读这个数据的时候才会递归。

收集依赖和以前差不多一个思路，收集的时候区分一下computed和reactive数据就好，
computed具体忘记了，大概和就是加了一个dirty属性判断是否可以缓存，然后get了一下value属性，同时和属性进行绑定了，因为属性改变，computed也要改变。

set触发依赖区分一下是改值还是新加就好，嗯，就是利用发布订阅模式。然后以前是使用数组，对象现在改成set，map而已


然后就是dom-diff

虚拟dom已经没有什么好优化的，优化在算法上

这玩意就是在render函数中调用一下patch，render函数又在effect函数中调用，
effect函数初始调用一次，值改变再调用一次，正好符合render调用机制

path这玩意就是先path自己的，再patch孩子进行递归，
比如patchProps 递归比较props就行，使用map数据结构保存一份index=>key的映射，防止元素移动位置比对错误

然后vue3的patch在算法上做了一些优化，什么头头比较，尾尾比较这些，具体算法早忘记了啊。

至于模板编译我觉得就是看自己正则水平怎么样啊，这个我没去看，个人感觉写一个简单的模板编译应该没有问题，因为有过一些正则的研究。



