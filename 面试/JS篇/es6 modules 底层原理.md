

1 首先建立依赖树，依赖树的建立是通过import语句来确认的。 还要给一个入口文件，用来确认依赖树的入口

2 浏览器理解不了这些文件，所以要把这些文件先转化成模块记录的一种数据结构，这样浏览器才能理解

3 然后将模块纪录 转化为模块实例 ，模块实例包含code和状态两种东西，code 就是一些指令，state 是变量在时间点的值

模块实例的产生步骤

构造 - 实例 - 求值


1 构造  1.1首先通过入口文件找到要下载的文件，然后文件中有import语句，找到import的说明符去找下一个文件

这个时候还没有进行求值，所以不能在import语句中使用变量，如果在构造的时候就求值会造成危害，如果某个模块下载太慢导致阻塞则会造成后面使用import语句的模块都被阻塞，而node可以使用变量，是因为node的构造，实例求值是一起完成的，原因是node读取本地磁盘速度很快。

但是动态导入又是需要的，所以会给动态导入创建一个新的依赖树。

一个模块只有一个实例，然后将实例缓存起来，这样无论多少个模块引入同一个模块，都只会引入一次


1.2  解析

首先将文件转化为模块记录，然后将模块记录存在模块map中，这意味着无论何时请求都可以从map中获取


在解析之前，要先知道这是不是应该模块，html加type = module即可，node使用mjs后缀文件


2 实例化  创建一个模块记录环境，这个模块记录环境保存着import和export之间的依赖关系，同时采用深度后序遍历算法，直到找到最底层，就是不依赖其他任何模块的模块，并且设置好他们的导出

当一个模块设置好所有的导出就会返回上一级设置所有的导入，这样的好处就是保证所有的模块都可以找到对应的导出且指向同一个地址，这样的好处就是当值修改时，导入的模块的值也会被时时修改，而commonJS 时对值的拷贝，并不能体现这一点。


3 求值 
通过执行js代码往内存中填值